`support` gibt ein Base64 Ticket zurück. Wenn man dieses Dekodiert bekommt man eine bzip datei. Entpackt enthält diese folgende Dateien:
```
tmp/keysafe-debug/
tmp/keysafe-debug/challenge
tmp/keysafe-debug/ipa
tmp/keysafe-debug/uname
tmp/keysafe-debug/cpuinfo
tmp/keysafe-debug/whoami
tmp/keysafe-debug/PATH
tmp/keysafe-debug/license
```

checksec:
```
RELRO           STACK CANARY      NX            PIE             RPATH      
Partial RELRO   No canary found   NX enabled    PIE enabled     No RPATH   

RUNPATH      Symbols         FORTIFY Fortified       Fortifiable     FILE
No RUNPATH   148 Symbols       No    0               7               ./challenge
```

## Flagge 1: License

Die erste Flagge steht in der Datei `license`

## Flagge 2: hidden command: fl4g

Nach ein wenig Reverse Engineering in Ghidra findet man 2 weitere Befehle `fl4g-obfuscated` und `fl4g`.
`fl4g` liefert die nächste Flagge. 

`fl4g-obfuscated` den Hinweis, dass man authentifiziert sein muss und man diese extra Flag bitte am Ende holt.

## Flagge 3: authentication

Den richtigen Hash für die Authentication zu finden ist eine Timing-Challenge:
Erst muss die richtige Länge ermittelt werden. Wenn die Länge stimmt benötigt der Algorithmus (durch das usleep im Code) wesentlich länger. So bekommt man heraus, dass der Hash 64 Zeichen lang ist.

Man schickt also immer einen String mit 64 Zeichen an den Server als füllzeichen habe ich ~ genommen, da dies garantiert nicht im Hash vorkommt. Die validen Zeichen sind `0-9 und a-f` .
Im Code sieht man, dass diesmal bei einem falschen zeichen länger gebraucht wird also sucht man diesmal die minimal Response-Time. Hier kommt der Hinweis mit dem nahegelegenen Server aus der Challenge-Beschreibung ins spiel, da das Timing vom der Attack box aus nicht funktioniert. Von dem genannten Server aber zuverlässig immer das selbe Ergebnis liefert.
So wird Zeichen für Zeichen der Hash `c83428bc433ed0f51219b8e0921e4f7c58efacc08fcb05ceb6d9c5776cfa17ed` ermittelt. (da man zwischendurch rausgeworfen wird, muss man mit dem bis dahin ermittelten Hash neu ansetzen.)

## Flagge 4: get-keys
```
<iv>
toau1sBv5rw1dXCcaONNwg==
</iv>
<ciphertext>
jTj6QUpSavtU/eZ0kEN196u29SWoiDAiIybmZ5kJzyfl9VYU6jT7EDtGVmaAtmKt
</ciphertext>
```

## Flagge 5: fl4g-obfuscated
```
<iv>
eUEzlsS2RwiFmt+2Mya83g==
</iv>
<ciphertext>
eueWQxBYX7/RBrzbty5rwcHvDtEP9Umwnaw73eRk4D0=
</ciphertext>
```

Mit einem Breakpoint nach dem Aufruf von der Funktion `deobfuscate` findet man den String `KerckhoffWouldNotBeHappy! :(`

Dieser wird zu einen Hash umgewandelt, um diesen als Key zu nutzen und auf dem heap gespeichert:
```
0x55555555f360: 0xc87686a080b8ed58      0x06b33c06b0c4935a
0x55555555f370: 0xfb72b554f869d07d      0x4996027e1596d848
```

In richtiger Byteorder ergibt sich: `58edb880a08676c85a93c4b0063cb3067dd069f854b572fb48d896157e029649`
was als Key für o.g. ciphertext funktioniert. Das Ergebnis ist die Flagge.

## Flagge 6: Server-Status
Es wird eine Flagge `FLAG_SERVER_STATUS` in einen Puffer kopiert, aber nie gelesen. Dieser Puffer liegt genau hinter dem Eingabepuffer für die Eingabe auf die Frage "What can I do for you today?". Wenn man dort 819 Bytes + ein "\\n" eingibt, gibt es zwischen beiden Puffern kein Nullbyte mehr und so wird die Flagge mit der Fehlermeldung, dass das `Command unrecognized` ist mitgeliefert.
